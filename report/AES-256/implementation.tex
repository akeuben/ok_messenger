There are two key considerations to our implementation: our block data structure and our $GF(2^8)$ implementation.
Each we will discuss seperately.

\textbf{Block Data Structure}

For all the algorithms that we have implemented, we made use of a \texttt{Block} class, which encapsulates a java 
\texttt{byte[]}. This provides a universal interface for our algorithms to use, and provides convinient operations 
that are used in individual algorithms. Below is a brief overview of the operations that this class supports:

\begin{lstlisting}[language=Java]
public class Block {
    public Block subData(int start, int end);

    public byte[] getData();

    public int getSizeBytes();
    public int getSizeBits();

    public Block xor(Block other);

    public Block byteWiseOperation(Function<Byte, Byte> operation);
    public Block rowWiseOperation(BiFunction<Byte[], Integer, Byte[]> operation);
    public Block columnWiseOperation(BiFunction<Byte[], Integer, Byte[]> operation);

    public static Block concat(Block ...blocks);
}
\end{lstlisting}

Here are a brief overview of these operations:
\begin{enumerate}
    \item \texttt{subdata}: Returns a subregion of the original block.
    \item \texttt{xor}: Returns a new block containing the XOR of the block with another block.
    \item \texttt{byteWiseOperation}: Maps each byte in the block to a new byte according to a user 
        defined operation.
    \item \texttt{rowWiseOperation}: Maps each row of the block to a new row according to a user
        defined operation.
    \item \texttt{columnWiseOperation}: Maps each column of the block to a new row according to a user
        defined operation.
    \item \texttt{concat}: Combines the given blocks into one large block.
\end{enumerate}

This makes implementing each stage of the AES algorithm trivial:

\begin{lstlisting}[language=Java]
public class AES {
    static Block Enc_AddRoundKey(Block data, Block roundKey) {
        assert data.getSizeBits() == 128;
        return data.xor(roundKey);
    }

    static Block Enc_SubBytes(Block data) {
        assert data.getSizeBits() == 128;
        return data.byteWiseOperation((b -> encryptionSTable[((int) b) & 0xFF]));
    }

    static Byte[] shiftRowLeft(Byte[] row, int count) {
        Byte[] newRow = new Byte[row.length];

        for(int i = 0; i < row.length; i++) {
            int idx = (i - count) % row.length;
            while(idx < 0) idx += row.length;
            newRow[idx] = row[i];
        }

        return newRow;
    }

    static Block Enc_ShiftRows(Block data) {
        assert data.getSizeBits() == 128;
        return data.rowWiseOperation(AES::shiftRowLeft);
    }

    static Block Enc_MixColumns(Block data) {
        assert data.getSizeBits() == 128;
        byte[] state = data.getData();
        for (int i = 0; i < 16; i += 4) {  // Process each column separately
            int s0 = state[i], s1 = state[i + 1], s2 = state[i + 2], s3 = state[i + 3];

            state[i]     = (byte) (GF256.multiply(s0, 2) ^ GF256.multiply(s1, 3) ^ GF256.multiply(s2, 1) ^ GF256.multiply(s3, 1));
            state[i + 1] = (byte) (GF256.multiply(s0, 1) ^ GF256.multiply(s1, 2) ^ GF256.multiply(s2, 3) ^ GF256.multiply(s3, 1));
            state[i + 2] = (byte) (GF256.multiply(s0, 1) ^ GF256.multiply(s1, 1) ^ GF256.multiply(s2, 2) ^ GF256.multiply(s3, 3));
            state[i + 3] = (byte) (GF256.multiply(s0, 3) ^ GF256.multiply(s1, 1) ^ GF256.multiply(s2, 1) ^ GF256.multiply(s3, 2));
        }

        return new Block(data.getSizeBytes(), state);
    }
}
\end{lstlisting}

\textbf{Galois Field Multiplication}

In order to implement $GF(2^8)$ multiplication, we at first implemented a nieve algorithm. The implementation is as follows:
\begin{lstlisting}[language=Java]
public static int multiply(int a, int b) {
    int result = 0;

    while (b > 0) {
        if ((b & 1) != 0) {  // If LSB of b is set, add a to result
            result ^= a; // Addition in GF(2) is XOR
        }

        boolean highBitSet = (a & 0x80) != 0; // Check if MSB is set
        a <<= 1; // Multiply by x (shift left)

        if (highBitSet) {
            a ^= MODULO; // Reduce modulo the irreducible polynomial
        }

        b >>= 1; // Move to next bit of b
    }

    return result & 0xFF; // Ensure 8-bit result
}
\end{lstlisting}
However, as the while loop is dependent on the \texttt{b} input, this implementation could 
be vulnerable to a timing side-channel attack. In order to prevent this, we instead at runtime generate 
a $256\times 256$ lookup table for all possible $GF(2^8)$ multiplications, using our nieve implementation above.
This ensures constant time lookups for any input to \texttt{multiply}, which is done by 
\begin{lstlisting}[language=Java]
public static int multiply(int a, int b) {
    return lookupTable[a][b]
}
\end{lstlisting}
ensuring that an attacker could not time our implementation to find information. 

\textbf{Takeaways}

Implementing AES-256 from scratch strengthened our understanding of the algorithm, especially with the 
key scheduling algorithm, as it was not covered in much detail during class, especially when it comes to 256-bit keys.
As with SHA-256 (as you will read below), we had a veriety of issues with Java not supporting unsigned integers of any length.
So, when splitting the key for the algorithm, we had to ensure that we masked off only the bits we were using and storing them in 
types larger than necessary. For example, commonly throughout the entire protocol, we had to store bytes in integer variables and use 
1 byte masks with \texttt{number \& 0xFF} to keep only the single byte after an operation.
