Double ratchet requires the following:
\begin{enumerate}
    \item Authenticated Encryption with Associated Data algorithm.
        
        For this, we chose to go with AES256 in CBC mode as it was taught in class
        and we were familiar with the conepts. Coincedentially, this is also the recommended 
        scheme by signal in their documentation. For the authentication, we make use of HMAC using 
        our SHA256-HMAC implementation. THis was also recommended by the signal authors, but our core
        reason for using SHA256 for HAMC was that we were already using it elsewhere in the application,
        and we were able to reuse it here as well. Further, SHA256 is industry standard, and gaining an 
        greater understanding of SHA256 was important to us, as the main goal of this project was to 
        explore all the technologies used in a modern cryptographic system.

    \item Key Derivation Functions 

        For this, we followed the singal authors recommendation of HMAC-SHA256 and HKDF as our 
        key derivation functions. Both make use of our SHA256 implementation. Additionally,
        both HKDF and HMAC-SHA256 are widely used in many cryptographic systems, including TLS,
        and has been tested for many years. They are widely understood to be strong and secure algorithms.

    \item Diffie-Hellman

        We are using the Java built-in Diffie-Hellman cryptographic libraries for our implementation.
        As we are using SHA256, curve25519 provides ~128-bit security, matching our SHA implementation (SHA256).
        Further, the smaller key size (compared to the other recommended algorithm, Curve448) reduces communication
        overhead which is already a problem with our implementation (which we will discuss later).
\end{enumerate}

As for implementation of the actual Double Ratchet algrorithm, we closely followed the documentation by signal.
The state for the algrorithm is maintained in the class fields, preventing us from needing to pass state around the application.
The interface is also very simple (see below).
\begin{lstlisting}[language=Java]
public class DoubleRatchet {
    public DoubleRatchet(Block SK, PublicKey otherPublicKey);
    public DoubleRatchet(Block SK, KeyPair myKeyPair);

    public DoubleRatchetMessage encrypt(Block plaintext, Block AD);
    public Block decrypt(DoubleRatchetMessage message, Block AD);
}
\end{lstlisting}
All other operations are encapsulated inside the class.

As with the other algrorithms implemented in our project, there are unit tests 
in place to ensure that the algorithm is behaving correctly, encrypting and decrypting 
messages properly, as well as skipping missed messages, or out of order messages.

Through the implementation (and more importantly, through debugging) the Double Ratchet algorithm, our understanding 
of how this system works was greatly improved. As it is rather difficult to fix something that you don't know how it 
works, fixing issues that popped up greatly improved our understanding. For example, during testing we found that 
sending multiple messages on one client in a row would crash the other client. In order to understand why the crash was occuring,
we had to form a stronger understanding of the Diffie-Hellman rachet, since, as we learned, the Diffie-Hellman ratchet only changes 
when you receive a message. Since we were sending multiple messages in a row, and since the issue was in properly updating the 
sending/receiving ratchet due to a change in the DH ratchet, fixing that issue required diving deeper into the DH ratchet, specifically when
it is responsible for updating.
